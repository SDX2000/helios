#!/usr/bin/python

import os
import sys
import re
import argparse

#from os.path import chdir

DBG_PRINT_VERBOSE = 1
DBG_PRINT_DEBUG = 2

CURRENT_DEBUG_LEVEL = 0

def dbg(level, s):
    if level <= CURRENT_DEBUG_LEVEL: #0 = least verbose >0 verbosity increases
        print s

class Pawk:
    __strFullExpr = r"""
    (?:/(?P<pattern>.*)/)
    \s*
    (?:\{(?P<action>.*)\})?     #Match and capture pattern + action
    """

    __strShortExpr = r"""
        /(?P<pattern>.*)/                #Match and capture pattern 
    |   \{(?P<action>.*)\}              #else match and capture actions
    """
    __flags = re.VERBOSE
    
    __regexActionPair = [] # [(regexobj, action)]
    
    __ignoreNewlines = False
    
    __currentLine = 0
    __currentLineNum = -1
    __currentFields = {}
    __currentGroups = {}
    __input = sys.stdin
    __output = sys.stdout
    
    def line(self):
        return self.__currentLine
        
    def lineNo(self):
        return self.__currentLineNum
        
    def fields(self):
        return self.__currentFields
        
    def groups(self):
        return self.__currentGroups
    
    def __init__(self, ignoreNewlines = False, input=sys.stdin, output=sys.stdout):
        __ignoreNewlines = ignoreNewlines
        __input = input
        
        __output = output
        
        if __ignoreNewlines:
            __flags |= re.DOTALLPYTHONPATH #Make the '.' special character match any character at all, including a newline; without this flag, '.' will match anything except a newline.
            
        self.__fullExprMatcher = re.compile(self.__strFullExpr, re.VERBOSE)
        self.__shortExpressionMatcher = re.compile(self.__strShortExpr, re.VERBOSE)

    def processScript(self, fileName):
        for line in open(fileName, 'r'):
            line = line.strip()
            if line.startswith('#') or line.startswith('//'):
                continue #ignore comments
            self.processExpression(line, args)
        
    def processExpression(self, expr):
        pattern = None
        action = None
        
        fem = self.__fullExprMatcher.match(expr)

        if fem:
            pattern = fem.group('pattern')
            action = fem.group('action')
        else:
            sem = self.__shortExpressionMatcher.match(expr)
            if sem:
                pattern = sem.group('pattern')
                action = sem.group('action')
        
        #save the pattern action pair for future use
        self.__regexActionPair.append((re.compile(pattern, re.VERBOSE), self.processAction(action)))
        

    
    def processAction(self, action):
        
        if not action:
            return None
        #print action
        action = re.sub(r'\$([_a-zA-Z][_a-zA-Z0-9]*)', r'_pawk.\1()', action)
        #print action
        action = re.sub(r'\$\{([_a-zA-Z][_a-zA-Z0-9]*\})', r'_pawk.__\1()', action)
        #print action
        action = re.sub(r'\$[0-9]+', '_pawk.__currentFields[\1]', action)
        #print action
        action = re.sub(r'\$\{[0-9]+\}', r'_pawk.__currentFields[\1]', action)
        #action = "def myaction(self):\n\tprint dir(self)\n\t%s" % action
        #print action
        return action
        
    def applyPatterns(self, line):
        for pattern, action in self.__regexActionPair:
            if pattern is not None:
                mo = pattern.search(line)
                if mo:
                    if action:
                        #print "Trying to execute action:\n%s\n" % action
                        exec action in {'_pawk':self}
                        #myaction(self)
                    else:
                        self.__output.write(line + '\n')
    def run(self):
        if not self.__ignoreNewlines:
            for line in self.__input:
                line = line.rstrip('\n')
                self.__currentLine = line
                self.__currentLineNum += 1
                self.__currentFields = line.split()
                self.applyPatterns(line)
        else:
            pass
        

parser = argparse.ArgumentParser(description='A python based substitute for awk')
parser.add_argument('expression', nargs='?') #nargs='?' makes 'script' optional
parser.add_argument('-e', dest='expression', help='A valid pawk expression of the form /pattern/ {action}.')
parser.add_argument('-f', '--file', metavar='script_file', help='A valid pawk script')
parser.add_argument('-w', '--ignore-newlines',dest='ignoreNewlines', action='store_true', help='ignore newlines and apply patterns to the whole file')

args = parser.parse_args()

pawk = Pawk(ignoreNewlines = args.ignoreNewlines)

if args.expression:
    pawk.processExpression(args.expression)

if args.file:
    pawk.processScript(args.file)

pawk.run()
